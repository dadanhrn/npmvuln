package npmvuln.jobs

import org.apache.spark.graphx.Graph
import com.github.gundy.semver4j.SemVer
import npmvuln.props._

object VulnerabilityScan1 {
  def getIterationCondition(graph: Graph[VertexProperties, EdgeProperties], level: Int): Boolean = {
    graph.triplets
      .filter(_.attr.isInstanceOf[DependsOnEdge])
      .filter(!_.srcAttr.asInstanceOf[PackageVertex].vulnerabilities.exists(_.level == level))
      .filter(_.dstAttr.isInstanceOf[PackageStateVertex])
      .count > 0
  }

  def vprogSnapshotEdge(graph: Graph[VertexProperties, EdgeProperties], level: Int): Unit = {
    graph.triplets
      .filter(_.attr.isInstanceOf[SnapshotEdge])
      .filter(_.srcAttr.asInstanceOf[PackageStateVertex].vulnRecords.exists(_.level == level))
      .foreach(t => {
        val release: PackageStateVertex = t.srcAttr.asInstanceOf[PackageStateVertex]
        val parent: PackageVertex = t.dstAttr.asInstanceOf[PackageVertex]

        parent.vulnerabilities = parent.vulnerabilities.union(release.vulnRecords)
        parent.vulnerabilities.foreach(_.immediateSource = release)
      })
  }

  def vprogDependsOnEdge(graph: Graph[VertexProperties, EdgeProperties], level: Int): Unit = {
    graph.triplets
      .filter(_.attr.isInstanceOf[DependsOnEdge])
      .filter(_.srcAttr.asInstanceOf[PackageVertex].vulnerabilities.exists(_.level == level))
      .foreach(t => {
        val dependency: PackageVertex = t.srcAttr.asInstanceOf[PackageVertex]
        val dependent: PackageStateVertex = t.dstAttr.asInstanceOf[PackageStateVertex]
        val constraint: String = t.attr.asInstanceOf[DependsOnEdge].dependencyConstraint

        val vulnerabilities: Array[VulnProperties] = dependency.vulnerabilities
          .filter(v => !dependent.vulnRecords.exists(_.id == v.id))
          .filter(v => SemVer.satisfies(v.immediateSource.version, constraint))
          .filter(v => v.period.overlaps(dependent.latestPeriod))

        vulnerabilities.foreach(v => {
          v.level += 1
          v.period = v.period.intersection(dependent.latestPeriod)
        })

        dependent.vulnRecords.union(vulnerabilities)
      })
  }

  def run(graph: Graph[VertexProperties, EdgeProperties]): Graph[VertexProperties, EdgeProperties] = {
    var level: Int = 0

    vprogSnapshotEdge(graph, level)

    while (getIterationCondition(graph, level)) {
      vprogDependsOnEdge(graph, level)
      vprogSnapshotEdge(graph, level)

      level += 1
    }

    graph
  }
}
