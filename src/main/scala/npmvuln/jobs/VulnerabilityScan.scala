package npmvuln.jobs

import org.apache.spark.graphx.{EdgeDirection, EdgeTriplet, Graph, PartitionStrategy, VertexId}
import com.github.gundy.semver4j.SemVer
import npmvuln.props._

object VulnerabilityScan {

  def vprog(vertexId: VertexId, prop: VertexProperties, message: Array[VulnProperties]): VertexProperties = {

    prop match {
      case PackageStateVertex(packageName, version, latestPeriod, vulnRecords) => {

        // Increment vulnerability level
        // then get intersected period
        message.foreach(vuln => {
          vuln.level += 1
          vuln.period = vuln.period.intersection(latestPeriod)
        })

        // Add vulnerabilities in message to vulnerability record
        prop.asInstanceOf[PackageStateVertex].vulnRecords = vulnRecords.union(message)

        // Return PackageStateVertex
        prop
      }

      case PackageVertex(packageName, vulnerabilities) => {

        // Add vulnerabilities from PackageStateVertex to records in their PackageVertex
        prop.asInstanceOf[PackageVertex].vulnerabilities = vulnerabilities.union(message)

        // Return PackageVertex
        prop
      }
    }
  }

  def sendMsg(triplet: EdgeTriplet[VertexProperties, EdgeProperties]): Iterator[(VertexId, Array[VulnProperties])] = {
    triplet.attr match {
      case SnapshotEdge(packageName, version) => {
        val release: PackageStateVertex = triplet.srcAttr.asInstanceOf[PackageStateVertex]
        val parent: PackageVertex = triplet.dstAttr.asInstanceOf[PackageVertex]

        // Filter out VulnProperties that exists on parent by ID
        val message: Array[VulnProperties] = release.vulnRecords
          .filter(vuln => !parent.vulnerabilities.exists(_.id == vuln.id))

        // Set immediateSource
        message.foreach(vuln => vuln.immediateSource = release)

        // Send message to parent PackageVertex
        if (message.length > 0){
          Iterator((triplet.dstId, message))
        } else {
          Iterator.empty
        }
      }

      case DependsOnEdge(constraint) => {
        val dependency: PackageVertex = triplet.srcAttr.asInstanceOf[PackageVertex]
        val dependent: PackageStateVertex = triplet.dstAttr.asInstanceOf[PackageStateVertex]

        // Filter out VulnProperties that exists on dependent by ID
        val message = dependency.vulnerabilities
          .filter(vuln => !dependent.vulnRecords.exists(_.id == vuln.id))

          // Filter out VulnProperties that doesn't match constraint
          .filter(vuln => SemVer.satisfies(vuln.immediateSource.version, constraint))

          // Filter out VulnProperties that doesn't overlaps destination PackageStateVertex
          .filter(_.period.overlaps(dependent.latestPeriod))

        // Send message to dependent PackageStateVertex
        if (message.length > 0){
          Iterator((triplet.dstId, message))
        } else {
          Iterator.empty
        }
      }
    }
  }

  def mergeMsg(msg1: Array[VulnProperties], msg2: Array[VulnProperties]): Array[VulnProperties] = {
    msg1.union(msg2)
  }

  def run(graph: Graph[VertexProperties, EdgeProperties], maxIterations: Int):
  Graph[VertexProperties, EdgeProperties] = {

    graph.pregel[Array[VulnProperties]](Array[VulnProperties](), maxIterations, EdgeDirection.Out)(
      vprog,
      sendMsg,
      mergeMsg
    ).partitionBy(PartitionStrategy.RandomVertexCut)

  }

  def vulnPropertiesReduce(vulnProps: Array[VulnProperties]): Array[VulnProperties] = {
    if (!vulnProps.isEmpty) {
      vulnProps
        .map(Array(_))
        .reduce((acm, avuln) => {
          val vuln2 = avuln.head
          var hasOverlapping = false
          acm.foreach(vuln1 => {
            if (vuln1.period.overlaps(vuln2.period)) {
              vuln1.period = vuln1.period.intersection(vuln2.period)
              hasOverlapping = true
            }
          })

          if (hasOverlapping) acm else acm :+ vuln2
        })
    } else {
      vulnProps
    }
  }

}
