package npmvuln.jobs

import org.apache.spark.graphx.{EdgeDirection, EdgeTriplet, Graph, VertexId}
import npmvuln.props._

object VulnerabilityScan {
  def vprog(vertexId: VertexId, prop: PackageStateVertex, message: Array[VulnProperties]): PackageStateVertex = {
    val satisfyingVuln: Array[VulnProperties] = message
      .filter(vuln => vuln.period.overlaps(prop.latestPeriod))

    satisfyingVuln.foreach(vuln => {
      vuln.period.intersection(prop.latestPeriod)
    })

    prop.vulnRecords = prop.vulnRecords.union(satisfyingVuln)
    prop
  }

  def sendMsg(triplet: EdgeTriplet[PackageStateVertex, Null]): Iterator[(VertexId, Array[VulnProperties])] = {
    val message: Array[VulnProperties] = triplet.srcAttr.vulnRecords
      .filter(vuln => vuln.period.overlaps(triplet.dstAttr.latestPeriod))

    if (message.length > 0){
      Iterator((triplet.dstId, message))
    } else {
      Iterator.empty
    }
  }

  def mergeMsg(msg1: Array[VulnProperties], msg2: Array[VulnProperties]): Array[VulnProperties] = {
    vulnPropertiesReduce(msg1.union(msg2))
  }

  def run (graph: Graph[PackageStateVertex, Null], maxIterations: Int):
  Graph[PackageStateVertex, Null] = {

    graph.pregel[Array[VulnProperties]](Array(), maxIterations, EdgeDirection.Out)(
      vprog,
      sendMsg,
      mergeMsg
    )

  }

  def vulnPropertiesReduce(vulnProps: Array[VulnProperties]): Array[VulnProperties] = {
    if (!vulnProps.isEmpty) {
      vulnProps
        .map(Array(_))
        .reduce((acm, avuln) => {
          val vuln2 = avuln.head
          var hasOverlapping = false
          acm.foreach(vuln1 => {
            if (vuln1.period.overlaps(vuln2.period)) {
              vuln1.period = vuln1.period.intersection(vuln2.period)
              hasOverlapping = true
            }
          })

          if (hasOverlapping) acm else acm :+ vuln2
        })
    } else {
      vulnProps
    }
  }
}