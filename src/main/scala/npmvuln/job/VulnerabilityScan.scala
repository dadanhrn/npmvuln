package npmvuln.job

import org.apache.spark.graphx.{EdgeDirection, EdgeTriplet, Graph, VertexId}
import com.github.gundy.semver4j.SemVer
import npmvuln.props._

object VulnerabilityScan {
  def vprog(vertexId: VertexId, prop: VertexProperties, message: Array[VulnProperties]): VertexProperties = {

    // Set immediateSource
    message.foreach(vuln => vuln.immediateSource = prop)

    prop match {
      case PackageStateVertex(packageName, version, releaseDate, vulnRecords) => {

        // Group VulnProperties by ID
        val msg = vulnPropertiesReduce(message)

        // Add vulnerabilities in message to vulnerability record
        prop.asInstanceOf[PackageStateVertex].vulnRecords = vulnRecords union msg

        // Return PackageStateVertex
        prop
      }

      case PackageVertex(packageName, vulnerabilities) => {

        // Add vulnerabilities from PackageStateVertex to records in their PackageVertex
        prop.asInstanceOf[PackageVertex].vulnerabilities = vulnerabilities union message

        // Return PackageStateVertex
        prop
      }
    }
  }

  def sendMsg(triplet: EdgeTriplet[VertexProperties, EdgeProperties]): Iterator[(VertexId, Array[VulnProperties])] = {
    triplet.attr match {
      case SnapshotEdge(packageName, version, snapshotPeriod) => {
        val release: PackageStateVertex = triplet.srcAttr.asInstanceOf[PackageStateVertex]

        // Get intersected interval between vulnerability period and snapshot period
        release.vulnRecords = release.vulnRecords
          .map(vuln => {
            vuln.period.intersection(snapshotPeriod)
            vuln
          })

        // Filter vulnerability whose period isn't inside snapshot period
        val message: Array[VulnProperties] = release.vulnRecords
          .filter(vuln => vuln.period.isConnected(snapshotPeriod))

//        // Get intersected interval between vulnerability period and snapshot period
//        message
//          .foreach(vuln => vuln.period = vuln.period.intersection(snapshotPeriod))

        // Send message to parent PackageVertex
        if (message.length > 0){
          Iterator((triplet.dstId, message))
        } else {
          Iterator.empty
        }
      }

      case DependsOnEdge(constraint) => {
        val dependency: PackageVertex = triplet.srcAttr.asInstanceOf[PackageVertex]

        // Filter VulnProperties that doesn't match constraint
        val message = dependency.vulnerabilities
          .filter(vuln => SemVer.satisfies(vuln.immediateSource.asInstanceOf[PackageStateVertex].version, constraint))

//        // Empty vulnerability storage on PackageVertex
//        dependency.vulnerabilities = Array.empty

        // Send message to dependent PackageStateVertex
        if (message.length > 0){
          Iterator((triplet.dstId, message))
        } else {
          Iterator.empty
        }
      }
    }
  }

  def mergeMsg(msg1: Array[VulnProperties], msg2: Array[VulnProperties]): Array[VulnProperties] = {
    val mergedVuln: Array[VulnProperties] = msg1 union msg2

    if (mergedVuln.isEmpty){
      mergedVuln
    } else {
      if (mergedVuln.head.immediateSource.isInstanceOf[PackageStateVertex]){
        vulnPropertiesReduce(msg1 union msg2)
      } else {
        mergedVuln
      }
    }
  }

  def run(graph: Graph[VertexProperties, EdgeProperties], maxIterations: Int): Graph[VertexProperties, EdgeProperties] = {

    graph.pregel[Array[VulnProperties]](Array(), maxIterations, EdgeDirection.Either)(
      vprog,
      sendMsg,
      mergeMsg
    )

  }

  def vulnPropertiesReduce(vulnProps: Array[VulnProperties]): Array[VulnProperties] = {
    if (!vulnProps.isEmpty) {
      vulnProps
        .map(Array(_))
        .reduce((acm, avuln) => {
          val vuln2 = avuln.head
          var hasOverlapping = false
          acm.foreach(vuln1 => {
            if (vuln1.period.overlaps(vuln2.period)) {
              vuln1.period = vuln1.period.intersection(vuln2.period)
              hasOverlapping = true
            }
          })

          if (hasOverlapping) acm else acm :+ vuln2
        })
    } else {
      vulnProps
    }
  }

}
