package npmvuln.job

import org.apache.spark.graphx.{EdgeDirection, EdgeTriplet, Graph, VertexId}
import com.github.gundy.semver4j.SemVer
import npmvuln.props._

object VulnerabilityScan {
  def vprog(vertexId: VertexId, prop: VertexProperties, message: Array[VulnProperties]): VertexProperties = {
    prop match {
      case PackageStateVertex(packageName, version, releaseDate, vulnRecords) => {

        // Group VulnProperties by ID
        val msg = message
          .groupBy(_.id)

          // Union vulnerabilities period within each group
          .mapValues(
            _.reduce(
              (vuln1, vuln2) => {
                vuln1.period = vuln1.period.union(vuln2.period)
                vuln1
              }
            )
          )

          // Convert back to array of VulnProperties
          .toArray.map(_._2)


        // Set vulnerability source to the PackageStateVertex it's currently on
        // then increment level
        msg
          .foreach(vuln =>{
            vuln.immediateSource = prop.asInstanceOf[PackageStateVertex]
            vuln.level += 1
          })

        // Add vulnerabilitues in message to vulnerability record
        prop.asInstanceOf[PackageStateVertex].vulnRecords = vulnRecords union msg

        // Return PackageStateVertex
        prop
      }

      case PackageVertex(packageName, vulnerabilities) => {

        // Add vulnerabilities from PackageStateVertex to records in their PackageVertex
        prop.asInstanceOf[PackageVertex].vulnerabilities = vulnerabilities union message

        // Return PackageStateVertex
        prop
      }
    }
  }

  def sendMsg(triplet: EdgeTriplet[VertexProperties, EdgeProperties]): Iterator[(VertexId, Array[VulnProperties])] = {
    triplet.attr match {
      case SnapshotEdge(packageName, version, snapshotPeriod) => {
        val release: PackageStateVertex = triplet.srcAttr.asInstanceOf[PackageStateVertex]

        // Filter vulnerability whose period isn't inside snapshot period
        val message: Array[VulnProperties] = release.vulnRecords
          .filter(vuln => vuln.period.isConnected(snapshotPeriod))

        // Get intersected interval between vulnerability period and snapshot period
        message
          .foreach(vuln => vuln.period = vuln.period.intersection(snapshotPeriod))

        // Send message to parent PackageVertex
        if (message.length > 0){
          Iterator((triplet.dstId, message))
        } else {
          Iterator.empty
        }
      }

      case DependsOnEdge(constraint) => {
        val dependency: PackageVertex = triplet.dstAttr.asInstanceOf[PackageVertex]

        // Filter VulnProperties that doesn't match constraint
        val message = dependency.vulnerabilities
          .filter(vuln => SemVer.satisfies(vuln.immediateSource.version, constraint))

        // Send message to dependent PackageStateVertex
        if (message.length > 0){
          Iterator((triplet.srcId, message))
        } else {
          Iterator.empty
        }
      }
    }
  }

  def mergeMsg(msg1: Array[VulnProperties], msg2: Array[VulnProperties]): Array[VulnProperties] = msg1 union msg2

  def run(graph: Graph[VertexProperties, EdgeProperties]): Graph[VertexProperties, EdgeProperties] = {

    graph.pregel[Array[VulnProperties]](Array(), 100, EdgeDirection.Either)(
      vprog,
      sendMsg,
      mergeMsg
    )

  }

}
